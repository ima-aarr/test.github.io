<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>COSMOS | ARCHIVE</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
    }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Syncopate:wght@400;700&family=Inter:wght@200;900&display=swap');
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Inter', sans-serif; touch-action: none; }
        canvas { display: block; }
        .ui-overlay { position: fixed; inset: 0; pointer-events: none; z-index: 10; display: flex; flex-col; justify-content: space-between; padding: 2rem; }
        .hero-text { font-family: 'Syncopate', sans-serif; background: linear-gradient(135deg, #fff 0%, #444 50%, #fff 100%); background-size: 200% auto; -webkit-background-clip: text; -webkit-text-fill-color: transparent; animation: shine 8s linear infinite; }
        @keyframes shine { to { background-position: 200% center; } }
        .noise { fixed: inset 0; opacity: 0.03; pointer-events: none; background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E"); }
        .btn { pointer-events: auto; background: rgba(255,255,255,0.03); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1); transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1); }
        .btn:hover { background: rgba(255,255,255,1); color: #000; transform: translateY(-2px); box-shadow: 0 10px 30px rgba(255,255,255,0.2); }
    </style>
</head>
<body>
    <div class="noise"></div>
    <div class="ui-overlay">
        <div class="flex justify-between items-start w-full opacity-40 text-[8px] tracking-[1.2em] uppercase">
            <div>Sector_0x88</div>
            <div>Multi_Dimensional_Interface</div>
        </div>

        <div class="text-center">
            <h1 class="hero-text text-5xl md:text-[11rem] font-black tracking-tighter leading-none mb-4 italic">
                YOUR NAME
            </h1>
            <p class="text-[9px] tracking-[2em] uppercase text-cyan-400 font-light opacity-60">Expanding the Digital Universe</p>
        </div>

        <div class="flex flex-col md:flex-row justify-between items-center w-full gap-8">
            <div class="text-[7px] text-white/20 font-mono text-left hidden md:block uppercase leading-relaxed">
                System: Stable<br>Neural: Connected<br>Universe: Expanding
            </div>
            <div class="flex gap-4">
                <button id="warp" class="btn px-10 py-4 text-[9px] tracking-[0.5em] font-bold">WARP</button>
                <button id="shift" class="btn px-10 py-4 text-[9px] tracking-[0.5em] font-bold">MORPH</button>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const galaxyGroup = new THREE.Group();
        scene.add(galaxyGroup);

        const createGalaxy = (count, size, color, radius) => {
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(count * 3);
            const col = new Float32Array(count * 3);
            const targetColor = new THREE.Color(color);

            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                const r = Math.random() * radius;
                const spin = r * 0.5;
                const angle = Math.random() * Math.PI * 2;
                
                pos[i3] = Math.cos(angle + spin) * r + (Math.random() - 0.5) * (r * 0.2);
                pos[i3+1] = (Math.random() - 0.5) * (r * 0.1);
                pos[i3+2] = Math.sin(angle + spin) * r + (Math.random() - 0.5) * (r * 0.2);

                col[i3] = targetColor.r * Math.random();
                col[i3+1] = targetColor.g * Math.random();
                col[i3+2] = targetColor.b * Math.random();
            }
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(col, 3));
            return new THREE.Points(geo, new THREE.PointsMaterial({ size: size, vertexColors: true, blending: THREE.AdditiveBlending, transparent: true, opacity: 0.6 }));
        };

        const coreGalaxy = createGalaxy(20000, 0.05, 0x00ffff, 40);
        const subGalaxy = createGalaxy(10000, 0.08, 0xff00ff, 60);
        galaxyGroup.add(coreGalaxy, subGalaxy);

        const shapes = [];
        const geometries = [new THREE.IcosahedronGeometry(2, 0), new THREE.TorusGeometry(15, 0.05, 16, 100), new THREE.OctahedronGeometry(10, 0)];
        geometries.forEach((g, i) => {
            const m = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true, opacity: 0.1 });
            const mesh = new THREE.Mesh(g, m);
            mesh.rotation.x = Math.random() * Math.PI;
            shapes.push(mesh);
            scene.add(mesh);
        });

        camera.position.z = 80;

        let mouseX = 0, mouseY = 0;
        let warp = 1;
        let morph = false;

        window.addEventListener('mousemove', (e) => {
            mouseX = (e.clientX / window.innerWidth - 0.5) * 2;
            mouseY = (e.clientY / window.innerHeight - 0.5) * 2;
        });

        window.addEventListener('touchmove', (e) => {
            mouseX = (e.touches[0].clientX / window.innerWidth - 0.5) * 2;
            mouseY = (e.touches[0].clientY / window.innerHeight - 0.5) * 2;
        });

        document.getElementById('warp').addEventListener('click', () => warp = warp === 1 ? 4 : 1);
        document.getElementById('shift').addEventListener('click', () => morph = !morph);

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;

            galaxyGroup.rotation.y += 0.001 * warp;
            galaxyGroup.rotation.z += 0.0005;
            
            shapes.forEach((s, i) => {
                s.rotation.y += 0.01;
                s.rotation.x += 0.005;
                if(morph) {
                    s.scale.setScalar(Math.sin(time + i) * 0.5 + 1.5);
                    s.material.opacity = Math.sin(time) * 0.2 + 0.1;
                } else {
                    s.scale.setScalar(1);
                    s.material.opacity = 0.1;
                }
            });

            camera.position.x += (mouseX * 30 - camera.position.x) * 0.05;
            camera.position.y += (-mouseY * 30 - camera.position.y) * 0.05;
            camera.position.z += ((morph ? 40 : 80) - camera.position.z) * 0.05;
            camera.lookAt(scene.position);

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
